#include <random>
#include <iostream>
#include <cstdio>

 
int main()
{

  int nsteps=100;
  int npaths=500;
  double ran=0.0;
  int cont = 0;
  int cont1 = nsteps;
 
  
  //int sumax = 0;
  //int sumay = 0;
  //int X [nsteps];
  
  //int Y [nsteps];
  float M [nsteps*npaths];
  float N [nsteps*npaths];
  float R [nsteps*npaths*2];
  float T [nsteps];

  // for(int i=0; i<nsteps; i++){
  // X[i]=0;
  // Y[i]=0;
  //}

  for(int i=0; i<nsteps; i++){
   T[i]=0.0;
  }


  

   for(int i=0; i<nsteps*npaths; i++){
    M[i]=0.0;
    N[i]=0.0;
    //R[i]=0.0;
    }

     for(int i=0; i<nsteps*npaths*2; i++){
    R[i]=0.0;
    }

     // int seed=1;
     // std::mt19937 gen(seed);
     
     std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(0.0, 1.0);

    for(int i=0; i<npaths; i++){
      // printf("%3d  ", i+1);
      int x=0;
      int y=0;
      //int sum=0;
      int cont2 = 0;     
      
    for (int n = 1; n <nsteps; ++n) {

      int a =1;
      int b =1;
      int c =1;
      int d =1;
      cont2 += 1;
      ran= dis(gen);
      int sum1=1;
      int sum2=1;
      int sum3=1;
      int sum4=1;
      double prob=0;
      // Use dis to transform the random unsigned int generated by gen into a 
        // double in [1, 2). Each call to dis(gen) generates a new random double

      for(int j=i*nsteps; j<n+i*nsteps; j++){
	  
	   if((x-1 == M[j]) && (y == N[j])){
	       a=0;
	       sum1 = 0;
	     }
	   if((x == M[j]) && (y-1 == N[j])){
	       b=0;
	       sum2 = 0;
	     }
	   if((x+1 == M[j]) && (y == N[j])){
	       c=0;
	       sum3 = 0;
	     }
	   if((x == M[j]) && (y+1 == N[j])){
	       d=0;
	       sum4 = 0;
	     }
      }

      if((a+b+c+d)==0){
	prob=0.0;
	n=nsteps;
	x=0;
	y=0;
	}

      prob = 1.0/(a+b+c+d);

      if(ran<(sum1)*a*prob ){
	x -=1;
      }
      else if(ran<(sum1 + sum2)*b*prob){
	y -=1;
      }
      else if(ran<(sum1 + sum2 + sum3)*c*prob){
	x +=1;
      }
      else if(ran<(sum1 + sum2 + sum3 + sum4)*d*prob){
	y +=1;
	}


	       M[n+i*nsteps] = 1.0*x;
	       N[n+i*nsteps] = 1.0*y;
	   
    }


    if(cont2 < cont1){
      cont1 = cont2;
    }
    

    for(int n=0; n<nsteps*npaths; n++){
      R[n]=M[n];
     }

    for(int n=nsteps*npaths ; n<2*nsteps*npaths; n++){
      R[n]=N[n-nsteps*npaths];
     }


    
    }


    for(int j=0; j<cont1; j++){
      for(int i=j; i<npaths*nsteps; i += nsteps){
	//printf("%5.0f %5.0f  ", R[i], R[i + nsteps*npaths]);
       T[j] += ((R[i]*R[i]) + ( R[i + nsteps*npaths]* R[i + nsteps*npaths]));
      }
      printf("%3d %5.3f ", cont, T[j]/npaths);
      // printf(" \n");
       cont++;
       for(int i=j; i<npaths*nsteps; i += nsteps){
	printf("%5.0f %5.0f  ", R[i], R[i + nsteps*npaths]);
	//T[j] += ((R[i]*R[i]) + ( R[i + nsteps*npaths]* R[i + nsteps*npaths]));
      }
        printf(" \n");
    } 
    
     //  printf(" \n");
     
    

     // delete [] X;
     // delete [] Y;
     //delete [] M;
     //delete [] N;
     //delete [] R;
}

