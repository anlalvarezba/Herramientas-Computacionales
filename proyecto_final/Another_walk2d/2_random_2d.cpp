#include <random>
#include <iostream>
#include <cstdio>

 
int main()
{

  int nsteps=10;
  int npaths=5;
  double ran=0.0;
  int cont = 1;
  
  //int sumax = 0;
  //int sumay = 0;
  //int X [nsteps];
  
  //int Y [nsteps];
  float M [nsteps*npaths];
  float N [nsteps*npaths];
  float R [nsteps*npaths*2];
  float T [nsteps];

  // for(int i=0; i<nsteps; i++){
  // X[i]=0;
  // Y[i]=0;
  //}

  for(int i=0; i<nsteps; i++){
   T[i]=0.0;
  }


  

   for(int i=0; i<nsteps*npaths; i++){
    M[i]=0.0;
    N[i]=0.0;
    //R[i]=0.0;
    }

     for(int i=0; i<nsteps*npaths*2; i++){
    R[i]=0.0;
    }
  
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(0.0, 1.0);

    for(int i=0; i<npaths; i++){
      // printf("%3d  ", i+1);
      int x=0;
      int y=0;
      //int sum=0;

     
      
    for (int n = 0; n <nsteps; ++n) {

      int a =1;
      int b =1;
      int c =1;
      int d =1;
      
      ran= dis(gen);
      int sum1=1;
      int sum2=1;
      int sum3=1;
      int sum4=1;
      double prob=0;
      // Use dis to transform the random unsigned int generated by gen into a 
        // double in [1, 2). Each call to dis(gen) generates a new random double

      for(int j=i*nsteps; j<n+i*nsteps; j++){
	 
	   if((x-1 == M[j]) && (y == N[j])){
	       a=0;
	       sum1 = 0;
	     }
	   if((x == M[j]) && (y-1 == N[j])){
	       b=0;
	       sum2 = 0;
	     }
	   if((x+1 == M[j]) && (y == N[j])){
	       c=0;
	       sum3 = 0;
	     }
	   if((x == M[j]) && (y+1 == N[j])){
	       d=0;
	       sum4 = 0;
	     }
      }

      if((a+b+c+d)==0){
	prob=0.0;
	n=nsteps;
	}

      prob = 1.0/(a+b+c+d);

      if(ran<(sum1)*a*prob ){
	x -=1;
      }
      else if(ran<(sum1 + sum2)*b*prob){
	y -=1;
      }
      else if(ran<(sum1 + sum2 + sum3)*c*prob){
	x +=1;
      }
      else if(ran<(sum1 + sum2 + sum3 + sum4)*d*prob){
	y +=1;
	}


	       M[n+i*nsteps] = 1.0*x;
	       N[n+i*nsteps] = 1.0*y;
	  

	   




/*
	
	 for(int j=i*nsteps; j<n+i*nsteps; j++){
	   if((M[n+i*nsteps] == M[j]) && (N[n+i*nsteps] == N[j])){
	       sum +=1;
	     }
        }


	  if((M[n+i*nsteps] == 0) && (N[n+i*nsteps] == 0)){
	       sum +=1;     
	     }

	  
	 if(0<sum && sum<4){
	   
	   // M[n+i*nsteps] = M[n+i*nsteps-1];
	   //N[n+i*nsteps] = N[n+i*nsteps-1];
	   n -=1;
	   //if(M[n+i*nsteps] != M[n+i*nsteps-1]){
	   //M[n+i*nsteps] = M[n+i*nsteps-1]);
	   //}
	   //if( N[n+i*nsteps] !=  N[n+i*nsteps-1]){
	   //N[n+i*nsteps] = N[n+i*nsteps-1]);
	   // }
	   
	 }

	 if(sum==4){
	   //if(M[n+i*nsteps] != M[n+i*nsteps-1]){
	   //M[n+i*nsteps] = M[n+i*nsteps-1]);
	   //}
	   //if( N[n+i*nsteps] !=  N[n+i*nsteps-1]){
	   //N[n+i*nsteps] = N[n+i*nsteps-1]);
	   //}
	   M[n+i*nsteps] = M[n+i*nsteps-1];
	   N[n+i*nsteps] = N[n+i*nsteps-1];
	   n=nsteps;
	 }

*/
	
	//R[i] += 1.0*((X[n]*X[n]) +(Y[n]*Y[n])) ;
	
	//printf("%3d %3d ", X[n], Y[n]);
    }
    
    // printf("%5.3f %5.3f  ", M[i]/npaths, N[i]/npaths);
    // printf("%5.3f %5.3f  ", (M[i]*M[i])/npaths,  (N[i]*N[i])/npaths);
    // printf("%5.3f  ", R[i]/npaths);

    for(int n=0; n<nsteps*npaths; n++){
      R[n]=M[n];
     }

    for(int n=nsteps*npaths ; n<2*nsteps*npaths; n++){
      R[n]=N[n-nsteps*npaths];
     }


    
    }

    /*
     for(int j=0; j<nsteps*npaths; j++){
       printf("%5.3f %5.3f  ", R[j], R[j+nsteps*npaths]);
       printf(" \n");
    }
    */

    for(int j=0; j<nsteps; j++){
      for(int i=j; i<npaths*nsteps; i += nsteps){
       printf("%5.0f %5.0f  ", R[i], R[i + nsteps*npaths]);
       T[j] += ((R[i]*R[i]) + ( R[i + nsteps*npaths]* R[i + nsteps*npaths]));
      }
      printf("%5.3f %3d ", T[j]/npaths, cont);
       printf(" \n");
       cont++;
    }



    
    
     //  printf(" \n");
     
    

     // delete [] X;
     // delete [] Y;
     //delete [] M;
     //delete [] N;
     //delete [] R;
}

