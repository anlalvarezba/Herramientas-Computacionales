#include <random>
#include <iostream>
#include <cstdio>

 
int main()
{

  int nsteps=1000;
  int npaths=5000;
  double ran=0.0;
  // int x=0;
  int *X = new int [npaths];
  int *Y = new int [npaths];
  int *Z = new int [npaths];

  
  float *M = new float [nsteps];
  float *N = new float [nsteps];
  float *P = new float [nsteps];
  float *R = new float [nsteps];

  for(int i=0; i<npaths; i++){
    X[i]=0;
    Y[i]=0;
    Z[i]=0;
  }

   for(int i=0; i<nsteps; i++){
    M[i]=0.0;
    N[i]=0.0;
    P[i]=0.0;
    R[i]=0.0;
    }
  
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(0.0, 1.0);

    double div = 1.0/6.0;

    for(int i=0; i<nsteps; i++){
       printf("%3d  ", i+1);
      
    for (int n = 0; n <npaths; ++n) {
      ran= dis(gen);
      // Use dis to transform the random unsigned int generated by gen into a 
        // double in [1, 2). Each call to dis(gen) generates a new random double
      if(ran<div){
	X[n] -=1;
      }
      else if(ran<2*div){
	Y[n] -=1;
      }
      else if(ran<3*div){
	Z[n] -=1;
      }
      else if(ran<4*div){
	X[n] +=1;
      }
      else if(ran<5*div){
	Y[n] +=1;
      }
      else{
	Z[n] +=1;
      }
    	
	M[i] += 1.0*X[n];
	N[i] += 1.0*Y[n];
	P[i] += 1.0*Z[n];
	R[i] += 1.0*((X[n]*X[n]) + (Y[n]*Y[n])  + (Z[n]*Z[n])) ;
	
	printf("%3d %3d  %3d ", X[n], Y[n], Z[n]);
    }
    // printf("%5.3f %5.3f  ", M[i]/npaths, N[i]/npaths);
    // printf("%5.3f %5.3f  ", (M[i]*M[i])/npaths,  (N[i]*N[i])/npaths);
    printf("%5.3f  ", R[i]/npaths);
    
     printf(" \n");
     
    }
}
